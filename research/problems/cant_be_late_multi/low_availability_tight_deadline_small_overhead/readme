Cant-Be-Late Multi-Region Scheduling Problem
================================

Problem Setting
---------------

You are given a long-running compute job that must complete before a fixed hard deadline.
At each time step, you must choose which AWS region to run in and which type of cloud compute resource to use:

- **Spot instances**  
  - Very cheap  
  - May become unavailable at certain timesteps  
  - Can be preempted at any time, the job will incur a **restart overhead**

- **On-demand instances**
  - Guaranteed available  
  - Expensive  
  - Never interrupted

- **Multi-region execution**
  - You may switch to another AWS region at any timestep
  - Switching regions forces a restart overhead (same as losing the work of the current timestep)
  - Spot availability differs per region based on real traces

Your strategy must decide at every timestep whether to use Spot, use On-Demand, or pause (NONE).

Your strategy can also switch to a different region at each step.

Restart overheads do not stack: launching a new instance while an old overhead is still pending will replace the previous remaining restart overhead with the new one.

Your goal is to **finish before the deadline** while **minimizing cost**.

The evaluation uses many real spot-availability traces.
---

API Specification
-----------------

Implement a `Solution` class:

```python
class Solution:
    def solve(self, spec_path: str = None) -> str | dict:
        """
        Returns a multi-region scheduling strategy.
        
        Returns one of:
        - Python code string implementing a MultiRegionStrategy subclass
        - {"code": "python_code_string"}
        - {"program_path": "path/to/strategy.py"}
        """
        # Your implementation
        pass
```

Your strategy code must implement:

```python
from sky_spot.strategies.multi_strategy import MultiRegionStrategy
from sky_spot.utils import ClusterType

class YourStrategy(MultiRegionStrategy):
    NAME = "your_strategy_name"  # REQUIRED: Add unique identifier
    
    def __init__(self, args=None):  # REQUIRED: Must accept args parameter
        super().__init__(args)
    
    def _is_behind_schedule(self) -> bool:  # REQUIRED: Must be implemented
        """Check if we're behind schedule based on progress vs deadline."""
        # Implement your logic here
        pass
    
    def _step(self, last_cluster_type: ClusterType, has_spot: bool) -> ClusterType:
        """
        Decide next action based on current state.
        
        Available attributes:
        - self.env.get_current_region(): Get current region index (0-8)
        - self.env.switch_region(idx): Switch to region by index
        - self.env.elapsed_seconds: Current time elapsed
        - self.task_duration: Total task duration needed
        - self.deadline: Deadline time
        - self._is_behind_schedule(): Check if job is behind schedule
        
        Returns: ClusterType.SPOT, ClusterType.ON_DEMAND, or ClusterType.NONE
        """
        # Implement your decision logic
        pass
    
    @classmethod
    def _from_args(cls, parser):  # REQUIRED: For evaluator instantiation
        args, _ = parser.parse_known_args()
        return cls(args)
```

Parameters:
---------------
### ClusterType:
ClusterType has 3 members: 

ClusterType.SPOT: Spot type cluster.

ClusterType.ON_DEMAND: On Demand type cluster.

ClusterType.None: None, no cluster.

#### You are given some fixed parameters:

env.gap_seconds: The size of each time step, in seconds.

task_duration: The total amount of work time required to finish the task (in seconds).

deadline: The task’s deadline (in seconds).

restart_overhead: The time overhead incurred when a job restarts.

You should implement the function to return the next cluster type to use as described above.

####  At each time step, you are given:

env.elapsed_seconds: Current time elapsed (in second).

env.cluster_type: The current cluster type running your task.

task_done_time: A list of completed work segments, where sum(self.task_done_time) = the amount of successful work time accumulated so far.

has_spot: A boolean indicating whether the Spot cluster is available in the current time step. If False, the strategy must not return ClusterType.SPOT (doing so will raise an error).

### You can use:

env.get_current_region(): Get your current region index (0-8).

env.switch_region(idx): Switch to region by index (no cost).

#### You should return:

ClusterType.SPOT: if you want to run the next time step on the Spot cluster.

ClusterType.ON_DEMAND: if you want to run the next time step on the On-Demand cluster.

ClusterType.NONE: if you choose not to run on any cluster during the next time step; this incurs no cost.

Scoring
-------
```
combined_score = -average_cost_across_all_scenarios
```

Negative cost: Lower cost = higher (less negative) score.

Notice that if you fail to finish the task before the deadline, you will receive a penalty score of -100000.

Evaluation Details
------------------
**Stage 1**: Quick check on 2-region scenario (must pass to proceed)  
**Stage 2**: Full evaluation on 6 scenarios:
- 2 zones same region (8 traces)
- 2 regions east-west (8 traces)
- 3 regions diverse (6 traces)
- 3 zones same region (6 traces)
- 5 regions high diversity (4 traces)
- All 9 regions (2 traces)


- Task duration: 48 hours
- Deadline: 52 hours (4-hour slack)
- Restart overhead: 0.2 hours
- Price of on-demand is 3.06$/hr
- Price of Spot is 0.9701$/hr

Your program has a total time limit of 300 seconds. You may be evaluated for up to 52 × 60 × 60 = 187200 time steps. Please ensure that your code is efficient under python.

Implementation Notes
---------------------
**Required Elements (Missing these will cause evaluation failures):**
- `NAME` attribute must be defined on your Strategy class (avoids "Name abstract already exists" error)
- `_from_args` classmethod must be implemented (avoids JSON decode errors)
- Ensure proper handling of ClusterType.NONE return values (avoids "Timestamp X out of range X" error)
- `__init__(self, args)` must match the Strategy base class (changed from `__init__(self, args=None)`)



Concrete Step Example:
----------------------
Here is a concrete example demonstrating our environment.
Assume we are:
```
Parameter                | Value
-------------------------|------------------------
env.gap_seconds          | 3600.0
env.elapsed_seconds      | 18000
task_done_time           | [3600, 3600, 2880, 3600, 3600]
has_spot                 | True
env.cluster_type         | ClusterType.SPOT
env.get_current_region() | 0
```
If we use env.switch_region(1), we will have:
```
Parameter                | Value
-------------------------|------------------------
env.gap_seconds          | 3600.0
env.elapsed_seconds      | 18000
task_done_time           | [3600, 3600, 2880, 3600, 3600]
has_spot                 | True
env.cluster_type         | ClusterType.SPOT
env.get_current_region() | 1
```
If our strategy returns ClusterType.ON_DEMAND, there will be a restart overhead:
```
Parameter                | Value
-------------------------|------------------------
env.gap_seconds          | 3600.0
env.elapsed_seconds      | 23400
task_done_time           | [3600, 3600, 2880, 3600, 3600, 2880]
has_spot                 | True
env.cluster_type         | ClusterType.ON_DEMAND
env.get_current_region() | 1
```
If our strategy returns ClusterType.SPOT:
```
Parameter                | Value
-------------------------|------------------------
env.gap_seconds          | 3600.0
env.elapsed_seconds      | 21600
task_done_time           | [3600, 3600, 2880, 3600, 3600, 3600]
has_spot                 | True
env.cluster_type         | ClusterType.SPOT
env.get_current_region() | 1
```