import os
import sys
import shutil
import tarfile
import subprocess
import random
import time
import tempfile
from concurrent.futures import ThreadPoolExecutor

class Solution:
    def solve(self, src_path: str) -> bytes:
        # 1. Setup workspace
        base_dir = os.path.abspath(os.getcwd())
        work_dir = os.path.join(base_dir, f"work_{int(time.time())}_{random.randint(0, 100000)}")
        if os.path.exists(work_dir):
            shutil.rmtree(work_dir)
        os.makedirs(work_dir)

        # 2. Extract Source
        try:
            with tarfile.open(src_path) as tar:
                # Extract carefully
                tar.extractall(path=work_dir)
        except Exception:
            pass

        # Locate root directory
        src_root = work_dir
        items = os.listdir(work_dir)
        if len(items) == 1 and os.path.isdir(os.path.join(work_dir, items[0])):
            src_root = os.path.join(work_dir, items[0])

        # 3. Build Target
        env = os.environ.copy()
        env['CC'] = 'clang'
        env['CXX'] = 'clang++'
        env['CFLAGS'] = '-fsanitize=address -g -O1'
        env['CXXFLAGS'] = '-fsanitize=address -g -O1'
        env['LDFLAGS'] = '-fsanitize=address'
        
        executable = None
        
        # Build Strategy 1: Meson
        if os.path.exists(os.path.join(src_root, 'meson.build')):
            build_dir = os.path.join(src_root, 'build_meson')
            try:
                subprocess.run(['meson', 'setup', build_dir], cwd=src_root, env=env, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=False)
                subprocess.run(['ninja', '-C', build_dir], cwd=src_root, env=env, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=False)
                # Find binary
                for r, d, f in os.walk(build_dir):
                    if 'ots-sanitize' in f:
                        executable = os.path.join(r, 'ots-sanitize')
                        break
            except: pass
            
        # Build Strategy 2: Autotools
        if not executable and os.path.exists(os.path.join(src_root, 'configure.ac')):
            try:
                subprocess.run(['./autogen.sh'], cwd=src_root, env=env, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=False)
                subprocess.run(['./configure'], cwd=src_root, env=env, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=False)
                subprocess.run(['make', '-j8'], cwd=src_root, env=env, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=False)
                # Find binary
                cand = os.path.join(src_root, 'ots-sanitize')
                if os.path.exists(cand):
                    # Check for libtool wrapper
                    is_wrapper = False
                    try:
                        with open(cand, 'rb') as f:
                            if b'Generated by libtool' in f.read(100):
                                is_wrapper = True
                    except: pass
                    
                    if is_wrapper:
                        cand_lib = os.path.join(src_root, '.libs', 'ots-sanitize')
                        if os.path.exists(cand_lib): executable = cand_lib
                        else: executable = cand
                    else:
                        executable = cand
            except: pass

        # Fallback binary search
        if not executable:
            for r, d, f in os.walk(work_dir):
                if 'ots-sanitize' in f:
                    cand = os.path.join(r, 'ots-sanitize')
                    if os.access(cand, os.X_OK):
                        executable = cand
                        break
        
        if not executable:
            # Cannot proceed effectively
            return b'ERROR_NO_BINARY'

        # 4. Gather Seeds
        seeds = []
        for r, d, f in os.walk(src_root):
            for file in f:
                if file.lower().endswith(('.ttf', '.otf', '.woff', '.woff2')):
                    try:
                        path = os.path.join(r, file)
                        with open(path, 'rb') as fin:
                            data = fin.read()
                            if len(data) < 200000: # Limit size
                                seeds.append(data)
                                # Heuristic: if filename looks related to target, boost priority
                                if 'arvo' in file.lower():
                                    for _ in range(5): seeds.append(data)
                    except: pass
        
        if not seeds:
            # Synthetic minimal valid font header
            seeds.append(b'\x00\x01\x00\x00' + b'\x00'*20)

        # 5. Fuzz Loop
        start_time = time.time()
        timeout = 200 # 3m 20s
        found_poc = None

        def check_poc(data):
            # Write to temp file
            fd, path = tempfile.mkstemp(dir=work_dir, prefix="fuzz")
            os.write(fd, data)
            os.close(fd)
            
            result = None
            try:
                # Run binary
                proc = subprocess.run([executable, path], capture_output=True, timeout=1)
                # Check for ASAN UAF
                if b"AddressSanitizer: heap-use-after-free" in proc.stderr:
                    result = data
            except subprocess.TimeoutExpired:
                pass
            except Exception:
                pass
            finally:
                if os.path.exists(path):
                    os.unlink(path)
            return result

        def mutate(base_data):
            b = bytearray(base_data)
            if not b: return b'\x00'
            method = random.randint(0, 3)
            l = len(b)
            if method == 0: # Byte flip
                b[random.randint(0, l-1)] = random.randint(0, 255)
            elif method == 1: # Bit flip
                b[random.randint(0, l-1)] ^= (1 << random.randint(0, 7))
            elif method == 2 and l > 4: # Int replace
                pos = random.randint(0, l-4)
                val = random.choice([b'\xff'*4, b'\x00'*4, b'\x7f\xff\xff\xff', b'\x80\x00\x00\x00'])
                b[pos:pos+4] = val
            elif method == 3 and l > 10: # Delete chunk
                start = random.randint(0, l-5)
                length = random.randint(1, 4)
                del b[start:start+length]
            return bytes(b)

        # Use ThreadPoolExecutor to maximize CPU usage
        with ThreadPoolExecutor(max_workers=8) as executor:
            while time.time() - start_time < timeout:
                futures = []
                for _ in range(16): # Batch submission
                    seed = random.choice(seeds)
                    mutated = mutate(seed)
                    futures.append(executor.submit(check_poc, mutated))
                
                for f in futures:
                    res = f.result()
                    if res:
                        found_poc = res
                        break
                if found_poc:
                    break
        
        # Cleanup
        try:
            shutil.rmtree(work_dir)
        except: pass
        
        if found_poc:
            return found_poc
        
        # Fallback to initial seed if no crash found
        return seeds[0] if seeds else b''
