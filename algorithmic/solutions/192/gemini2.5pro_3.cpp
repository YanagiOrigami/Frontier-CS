#include <iostream>
#include <vector>
#include <queue>

void setup_io() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
}

int main() {
    setup_io();

    int n, m;
    std::cin >> n >> m;

    std::vector<std::vector<int>> adj(n + 1);
    for (int i = 0; i < m; ++i) {
        int u, v;
        std::cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    // The Max-Cut problem is NP-hard. We use a strong heuristic:
    // 1. Start with an initial partition generated by a BFS-based 2-coloring.
    //    This is optimal for bipartite components of the graph.
    // 2. Improve this partition using a greedy local search algorithm.
    //    Repeatedly iterate over all vertices and flip a vertex's set if
    //    doing so increases the number of cut edges.

    std::vector<int> color(n + 1, -1);

    // Step 1: Initial partition using BFS 2-coloring
    for (int i = 1; i <= n; ++i) {
        if (color[i] == -1) {
            std::queue<int> q;
            q.push(i);
            color[i] = 0;
            while (!q.empty()) {
                int u = q.front();
                q.pop();
                for (int v : adj[u]) {
                    if (color[v] == -1) {
                        color[v] = 1 - color[u];
                        q.push(v);
                    }
                }
            }
        }
    }

    // Step 2: Refinement using greedy local search
    const int MAX_ITER = 20; // A few passes are usually sufficient
    for (int iter = 0; iter < MAX_ITER; ++iter) {
        bool changed = false;
        for (int u = 1; u <= n; ++u) {
            int same_color_neighbors = 0;
            for (int v : adj[u]) {
                if (color[v] == color[u]) {
                    same_color_neighbors++;
                }
            }

            // A move is beneficial if the number of neighbors in the same set
            // is greater than the number of neighbors in the other set.
            // This is equivalent to 2 * same_color_neighbors > degree(u).
            if (2 * same_color_neighbors > (int)adj[u].size()) {
                color[u] = 1 - color[u];
                changed = true;
            }
        }
        if (!changed) {
            // No improvement in a full pass, we reached a local optimum.
            break;
        }
    }

    // Output the final partition
    for (int i = 1; i <= n; ++i) {
        std::cout << color[i] << (i == n ? "" : " ");
    }
    std::cout << std::endl;

    return 0;
}